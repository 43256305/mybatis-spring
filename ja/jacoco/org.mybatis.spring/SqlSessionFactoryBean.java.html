<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlSessionFactoryBean.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis-spring</a> &gt; <a href="index.source.html" class="el_package">org.mybatis.spring</a> &gt; <span class="el_source">SqlSessionFactoryBean.java</span></div><h1>SqlSessionFactoryBean.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2010-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.mybatis.spring;

import static org.springframework.util.Assert.notNull;
import static org.springframework.util.Assert.state;
import static org.springframework.util.ObjectUtils.isEmpty;
import static org.springframework.util.StringUtils.hasLength;
import static org.springframework.util.StringUtils.tokenizeToStringArray;

import java.io.IOException;
import java.lang.reflect.Modifier;
import java.sql.SQLException;
import java.util.HashSet;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Stream;

import javax.sql.DataSource;

import org.apache.ibatis.builder.xml.XMLConfigBuilder;
import org.apache.ibatis.builder.xml.XMLMapperBuilder;
import org.apache.ibatis.cache.Cache;
import org.apache.ibatis.executor.ErrorContext;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.io.VFS;
import org.apache.ibatis.mapping.DatabaseIdProvider;
import org.apache.ibatis.mapping.Environment;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.reflection.factory.ObjectFactory;
import org.apache.ibatis.reflection.wrapper.ObjectWrapperFactory;
import org.apache.ibatis.scripting.LanguageDriver;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.apache.ibatis.transaction.TransactionFactory;
import org.apache.ibatis.type.TypeHandler;
import org.mybatis.logging.Logger;
import org.mybatis.logging.LoggerFactory;
import org.mybatis.spring.transaction.SpringManagedTransactionFactory;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.core.type.ClassMetadata;
import org.springframework.core.type.classreading.CachingMetadataReaderFactory;
import org.springframework.core.type.classreading.MetadataReaderFactory;
import org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy;
import org.springframework.util.ClassUtils;

/**
 * {@code FactoryBean} that creates a MyBatis {@code SqlSessionFactory}. This is the usual way to set up a shared
 * MyBatis {@code SqlSessionFactory} in a Spring application context; the SqlSessionFactory can then be passed to
 * MyBatis-based DAOs via dependency injection.
 * &lt;p&gt;
 * Either {@code DataSourceTransactionManager} or {@code JtaTransactionManager} can be used for transaction demarcation
 * in combination with a {@code SqlSessionFactory}. JTA should be used for transactions which span multiple databases or
 * when container managed transactions (CMT) are being used.
 *
 * @author Putthiphong Boonphong
 * @author Hunter Presnall
 * @author Eduardo Macarron
 * @author Eddú Meléndez
 * @author Kazuki Shimizu
 * @author Jens Schauder
 *
 * @see #setConfigLocation
 * @see #setDataSource
 */
<span class="fc" id="L89">public class SqlSessionFactoryBean</span>
    implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; {

<span class="fc" id="L92">  private static final Logger LOGGER = LoggerFactory.getLogger(SqlSessionFactoryBean.class);</span>

<span class="fc" id="L94">  private static final ResourcePatternResolver RESOURCE_PATTERN_RESOLVER = new PathMatchingResourcePatternResolver();</span>
<span class="fc" id="L95">  private static final MetadataReaderFactory METADATA_READER_FACTORY = new CachingMetadataReaderFactory();</span>

  private Resource configLocation;

  private Configuration configuration;

  private Resource[] mapperLocations;

  private DataSource dataSource;

  private TransactionFactory transactionFactory;

  private Properties configurationProperties;

<span class="fc" id="L109">  private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span>

  private SqlSessionFactory sqlSessionFactory;

  // EnvironmentAware requires spring 3.1
<span class="fc" id="L114">  private String environment = SqlSessionFactoryBean.class.getSimpleName();</span>

  private boolean failFast;

  private Interceptor[] plugins;

  private TypeHandler&lt;?&gt;[] typeHandlers;

  private String typeHandlersPackage;

  @SuppressWarnings(&quot;rawtypes&quot;)
  private Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler;

  private Class&lt;?&gt;[] typeAliases;

  private String typeAliasesPackage;

  private Class&lt;?&gt; typeAliasesSuperType;

  private LanguageDriver[] scriptingLanguageDrivers;

  private Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver;

  // issue #19. No default provider.
  private DatabaseIdProvider databaseIdProvider;

  private Class&lt;? extends VFS&gt; vfs;

  private Cache cache;

  private ObjectFactory objectFactory;

  private ObjectWrapperFactory objectWrapperFactory;

  /**
   * Sets the ObjectFactory.
   *
   * @since 1.1.2
   *
   * @param objectFactory
   *          a custom ObjectFactory
   */
  public void setObjectFactory(ObjectFactory objectFactory) {
<span class="fc" id="L157">    this.objectFactory = objectFactory;</span>
<span class="fc" id="L158">  }</span>

  /**
   * Sets the ObjectWrapperFactory.
   *
   * @since 1.1.2
   *
   * @param objectWrapperFactory
   *          a specified ObjectWrapperFactory
   */
  public void setObjectWrapperFactory(ObjectWrapperFactory objectWrapperFactory) {
<span class="fc" id="L169">    this.objectWrapperFactory = objectWrapperFactory;</span>
<span class="fc" id="L170">  }</span>

  /**
   * Gets the DatabaseIdProvider
   *
   * @since 1.1.0
   *
   * @return a specified DatabaseIdProvider
   */
  public DatabaseIdProvider getDatabaseIdProvider() {
<span class="nc" id="L180">    return databaseIdProvider;</span>
  }

  /**
   * Sets the DatabaseIdProvider. As of version 1.2.2 this variable is not initialized by default.
   *
   * @since 1.1.0
   *
   * @param databaseIdProvider
   *          a DatabaseIdProvider
   */
  public void setDatabaseIdProvider(DatabaseIdProvider databaseIdProvider) {
<span class="fc" id="L192">    this.databaseIdProvider = databaseIdProvider;</span>
<span class="fc" id="L193">  }</span>

  /**
   * Gets the VFS.
   *
   * @return a specified VFS
   */
  public Class&lt;? extends VFS&gt; getVfs() {
<span class="nc" id="L201">    return this.vfs;</span>
  }

  /**
   * Sets the VFS.
   *
   * @param vfs
   *          a VFS
   */
  public void setVfs(Class&lt;? extends VFS&gt; vfs) {
<span class="nc" id="L211">    this.vfs = vfs;</span>
<span class="nc" id="L212">  }</span>

  /**
   * Gets the Cache.
   *
   * @return a specified Cache
   */
  public Cache getCache() {
<span class="fc" id="L220">    return this.cache;</span>
  }

  /**
   * Sets the Cache.
   *
   * @param cache
   *          a Cache
   */
  public void setCache(Cache cache) {
<span class="fc" id="L230">    this.cache = cache;</span>
<span class="fc" id="L231">  }</span>

  /**
   * Mybatis plugin list.
   *
   * @since 1.0.1
   *
   * @param plugins
   *          list of plugins
   */
  public void setPlugins(Interceptor... plugins) {
<span class="fc" id="L242">    this.plugins = plugins;</span>
<span class="fc" id="L243">  }</span>

  /**
   * Packages to search for type aliases.
   * &lt;p&gt;
   * Since 2.0.1, allow to specify a wildcard such as {@code com.example.*.model}.
   *
   * @since 1.0.1
   *
   * @param typeAliasesPackage
   *          package to scan for domain objects
   */
  public void setTypeAliasesPackage(String typeAliasesPackage) {
<span class="fc" id="L256">    this.typeAliasesPackage = typeAliasesPackage;</span>
<span class="fc" id="L257">  }</span>

  /**
   * Super class which domain objects have to extend to have a type alias created. No effect if there is no package to
   * scan configured.
   *
   * @since 1.1.2
   *
   * @param typeAliasesSuperType
   *          super class for domain objects
   */
  public void setTypeAliasesSuperType(Class&lt;?&gt; typeAliasesSuperType) {
<span class="fc" id="L269">    this.typeAliasesSuperType = typeAliasesSuperType;</span>
<span class="fc" id="L270">  }</span>

  /**
   * Packages to search for type handlers.
   * &lt;p&gt;
   * Since 2.0.1, allow to specify a wildcard such as {@code com.example.*.typehandler}.
   *
   * @since 1.0.1
   *
   * @param typeHandlersPackage
   *          package to scan for type handlers
   */
  public void setTypeHandlersPackage(String typeHandlersPackage) {
<span class="fc" id="L283">    this.typeHandlersPackage = typeHandlersPackage;</span>
<span class="fc" id="L284">  }</span>

  /**
   * Set type handlers. They must be annotated with {@code MappedTypes} and optionally with {@code MappedJdbcTypes}
   *
   * @since 1.0.1
   *
   * @param typeHandlers
   *          Type handler list
   */
  public void setTypeHandlers(TypeHandler&lt;?&gt;... typeHandlers) {
<span class="fc" id="L295">    this.typeHandlers = typeHandlers;</span>
<span class="fc" id="L296">  }</span>

  /**
   * Set the default type handler class for enum.
   *
   * @since 2.0.5
   *
   * @param defaultEnumTypeHandler
   *          The default type handler class for enum
   */
  public void setDefaultEnumTypeHandler(
      @SuppressWarnings(&quot;rawtypes&quot;) Class&lt;? extends TypeHandler&gt; defaultEnumTypeHandler) {
<span class="fc" id="L308">    this.defaultEnumTypeHandler = defaultEnumTypeHandler;</span>
<span class="fc" id="L309">  }</span>

  /**
   * List of type aliases to register. They can be annotated with {@code Alias}
   *
   * @since 1.0.1
   *
   * @param typeAliases
   *          Type aliases list
   */
  public void setTypeAliases(Class&lt;?&gt;... typeAliases) {
<span class="fc" id="L320">    this.typeAliases = typeAliases;</span>
<span class="fc" id="L321">  }</span>

  /**
   * If true, a final check is done on Configuration to assure that all mapped statements are fully loaded and there is
   * no one still pending to resolve includes. Defaults to false.
   *
   * @since 1.0.1
   *
   * @param failFast
   *          enable failFast
   */
  public void setFailFast(boolean failFast) {
<span class="nc" id="L333">    this.failFast = failFast;</span>
<span class="nc" id="L334">  }</span>

  /**
   * Set the location of the MyBatis {@code SqlSessionFactory} config file. A typical value is
   * &quot;WEB-INF/mybatis-configuration.xml&quot;.
   *
   * @param configLocation
   *          a location the MyBatis config file
   */
  public void setConfigLocation(Resource configLocation) {
<span class="fc" id="L344">    this.configLocation = configLocation;</span>
<span class="fc" id="L345">  }</span>

  /**
   * Set a customized MyBatis configuration.
   *
   * @param configuration
   *          MyBatis configuration
   *
   * @since 1.3.0
   */
  public void setConfiguration(Configuration configuration) {
<span class="fc" id="L356">    this.configuration = configuration;</span>
<span class="fc" id="L357">  }</span>

  /**
   * Set locations of MyBatis mapper files that are going to be merged into the {@code SqlSessionFactory} configuration
   * at runtime.
   * &lt;p&gt;
   * This is an alternative to specifying &quot;&amp;lt;sqlmapper&amp;gt;&quot; entries in an MyBatis config file. This property being
   * based on Spring's resource abstraction also allows for specifying resource patterns here: e.g.
   * &quot;classpath*:sqlmap/*-mapper.xml&quot;.
   *
   * @param mapperLocations
   *          location of MyBatis mapper files
   */
  public void setMapperLocations(Resource... mapperLocations) {
<span class="fc" id="L371">    this.mapperLocations = mapperLocations;</span>
<span class="fc" id="L372">  }</span>

  /**
   * Set optional properties to be passed into the SqlSession configuration, as alternative to a
   * {@code &amp;lt;properties&amp;gt;} tag in the configuration xml file. This will be used to resolve placeholders in the
   * config file.
   *
   * @param sqlSessionFactoryProperties
   *          optional properties for the SqlSessionFactory
   */
  public void setConfigurationProperties(Properties sqlSessionFactoryProperties) {
<span class="fc" id="L383">    this.configurationProperties = sqlSessionFactoryProperties;</span>
<span class="fc" id="L384">  }</span>

  /**
   * Set the JDBC {@code DataSource} that this instance should manage transactions for. The {@code DataSource} should
   * match the one used by the {@code SqlSessionFactory}: for example, you could specify the same JNDI DataSource for
   * both.
   * &lt;p&gt;
   * A transactional JDBC {@code Connection} for this {@code DataSource} will be provided to application code accessing
   * this {@code DataSource} directly via {@code DataSourceUtils} or {@code DataSourceTransactionManager}.
   * &lt;p&gt;
   * The {@code DataSource} specified here should be the target {@code DataSource} to manage transactions for, not a
   * {@code TransactionAwareDataSourceProxy}. Only data access code may work with
   * {@code TransactionAwareDataSourceProxy}, while the transaction manager needs to work on the underlying target
   * {@code DataSource}. If there's nevertheless a {@code TransactionAwareDataSourceProxy} passed in, it will be
   * unwrapped to extract its target {@code DataSource}.
   *
   * @param dataSource
   *          a JDBC {@code DataSource}
   */
  public void setDataSource(DataSource dataSource) {
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">    if (dataSource instanceof TransactionAwareDataSourceProxy) {</span>
      // If we got a TransactionAwareDataSourceProxy, we need to perform
      // transactions for its underlying target DataSource, else data
      // access code won't see properly exposed transactions (i.e.
      // transactions for the target DataSource).
<span class="nc" id="L409">      this.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource();</span>
    } else {
<span class="fc" id="L411">      this.dataSource = dataSource;</span>
    }
<span class="fc" id="L413">  }</span>

  /**
   * Sets the {@code SqlSessionFactoryBuilder} to use when creating the {@code SqlSessionFactory}.
   * &lt;p&gt;
   * This is mainly meant for testing so that mock SqlSessionFactory classes can be injected. By default,
   * {@code SqlSessionFactoryBuilder} creates {@code DefaultSqlSessionFactory} instances.
   *
   * @param sqlSessionFactoryBuilder
   *          a SqlSessionFactoryBuilder
   */
  public void setSqlSessionFactoryBuilder(SqlSessionFactoryBuilder sqlSessionFactoryBuilder) {
<span class="fc" id="L425">    this.sqlSessionFactoryBuilder = sqlSessionFactoryBuilder;</span>
<span class="fc" id="L426">  }</span>

  /**
   * Set the MyBatis TransactionFactory to use. Default is {@code SpringManagedTransactionFactory}.
   * &lt;p&gt;
   * The default {@code SpringManagedTransactionFactory} should be appropriate for all cases: be it Spring transaction
   * management, EJB CMT or plain JTA. If there is no active transaction, SqlSession operations will execute SQL
   * statements non-transactionally.
   * &lt;p&gt;
   * &lt;b&gt;It is strongly recommended to use the default {@code TransactionFactory}.&lt;/b&gt; If not used, any attempt at
   * getting an SqlSession through Spring's MyBatis framework will throw an exception if a transaction is active.
   *
   * @see SpringManagedTransactionFactory
   *
   * @param transactionFactory
   *          the MyBatis TransactionFactory
   */
  public void setTransactionFactory(TransactionFactory transactionFactory) {
<span class="fc" id="L444">    this.transactionFactory = transactionFactory;</span>
<span class="fc" id="L445">  }</span>

  /**
   * &lt;b&gt;NOTE:&lt;/b&gt; This class &lt;em&gt;overrides&lt;/em&gt; any {@code Environment} you have set in the MyBatis config file. This is
   * used only as a placeholder name. The default value is {@code SqlSessionFactoryBean.class.getSimpleName()}.
   *
   * @param environment
   *          the environment name
   */
  public void setEnvironment(String environment) {
<span class="fc" id="L455">    this.environment = environment;</span>
<span class="fc" id="L456">  }</span>

  /**
   * Set scripting language drivers.
   *
   * @param scriptingLanguageDrivers
   *          scripting language drivers
   *
   * @since 2.0.2
   */
  public void setScriptingLanguageDrivers(LanguageDriver... scriptingLanguageDrivers) {
<span class="fc" id="L467">    this.scriptingLanguageDrivers = scriptingLanguageDrivers;</span>
<span class="fc" id="L468">  }</span>

  /**
   * Set a default scripting language driver class.
   *
   * @param defaultScriptingLanguageDriver
   *          A default scripting language driver class
   *
   * @since 2.0.2
   */
  public void setDefaultScriptingLanguageDriver(Class&lt;? extends LanguageDriver&gt; defaultScriptingLanguageDriver) {
<span class="fc" id="L479">    this.defaultScriptingLanguageDriver = defaultScriptingLanguageDriver;</span>
<span class="fc" id="L480">  }</span>

  /**
   * {@inheritDoc}
   */
  @Override
  public void afterPropertiesSet() throws Exception {
<span class="fc" id="L487">    notNull(dataSource, &quot;Property 'dataSource' is required&quot;);</span>
<span class="fc" id="L488">    notNull(sqlSessionFactoryBuilder, &quot;Property 'sqlSessionFactoryBuilder' is required&quot;);</span>
<span class="fc bfc" id="L489" title="All 8 branches covered.">    state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null),</span>
        &quot;Property 'configuration' and 'configLocation' can not specified with together&quot;);

<span class="fc" id="L492">    this.sqlSessionFactory = buildSqlSessionFactory();</span>
<span class="fc" id="L493">  }</span>

  /**
   * Build a {@code SqlSessionFactory} instance.
   * &lt;p&gt;
   * The default implementation uses the standard MyBatis {@code XMLConfigBuilder} API to build a
   * {@code SqlSessionFactory} instance based on a Reader. Since 1.3.0, it can be specified a {@link Configuration}
   * instance directly(without config file).
   *
   * @return SqlSessionFactory
   *
   * @throws Exception
   *           if configuration is failed
   */
  protected SqlSessionFactory buildSqlSessionFactory() throws Exception {

    final Configuration targetConfiguration;

<span class="fc" id="L511">    XMLConfigBuilder xmlConfigBuilder = null;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">    if (this.configuration != null) {</span>
<span class="fc" id="L513">      targetConfiguration = this.configuration;</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">      if (targetConfiguration.getVariables() == null) {</span>
<span class="fc" id="L515">        targetConfiguration.setVariables(this.configurationProperties);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">      } else if (this.configurationProperties != null) {</span>
<span class="fc" id="L517">        targetConfiguration.getVariables().putAll(this.configurationProperties);</span>
      }
<span class="fc bfc" id="L519" title="All 2 branches covered.">    } else if (this.configLocation != null) {</span>
<span class="fc" id="L520">      xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);</span>
<span class="fc" id="L521">      targetConfiguration = xmlConfigBuilder.getConfiguration();</span>
    } else {
<span class="fc" id="L523">      LOGGER.debug(</span>
<span class="nc" id="L524">          () -&gt; &quot;Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration&quot;);</span>
<span class="fc" id="L525">      targetConfiguration = new Configuration();</span>
<span class="fc" id="L526">      Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables);</span>
    }

<span class="fc" id="L529">    Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory);</span>
<span class="fc" id="L530">    Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory);</span>
<span class="fc" id="L531">    Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl);</span>

<span class="fc bfc" id="L533" title="All 2 branches covered.">    if (hasLength(this.typeAliasesPackage)) {</span>
<span class="fc" id="L534">      scanClasses(this.typeAliasesPackage, this.typeAliasesSuperType).stream()</span>
<span class="fc bfc" id="L535" title="All 4 branches covered.">          .filter(clazz -&gt; !clazz.isAnonymousClass()).filter(clazz -&gt; !clazz.isInterface())</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">          .filter(clazz -&gt; !clazz.isMemberClass()).forEach(targetConfiguration.getTypeAliasRegistry()::registerAlias);</span>
    }

<span class="fc bfc" id="L539" title="All 2 branches covered.">    if (!isEmpty(this.typeAliases)) {</span>
<span class="fc" id="L540">      Stream.of(this.typeAliases).forEach(typeAlias -&gt; {</span>
<span class="fc" id="L541">        targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias);</span>
<span class="pc" id="L542">        LOGGER.debug(() -&gt; &quot;Registered type alias: '&quot; + typeAlias + &quot;'&quot;);</span>
<span class="fc" id="L543">      });</span>
    }

<span class="fc bfc" id="L546" title="All 2 branches covered.">    if (!isEmpty(this.plugins)) {</span>
<span class="fc" id="L547">      Stream.of(this.plugins).forEach(plugin -&gt; {</span>
<span class="fc" id="L548">        targetConfiguration.addInterceptor(plugin);</span>
<span class="pc" id="L549">        LOGGER.debug(() -&gt; &quot;Registered plugin: '&quot; + plugin + &quot;'&quot;);</span>
<span class="fc" id="L550">      });</span>
    }

<span class="fc bfc" id="L553" title="All 2 branches covered.">    if (hasLength(this.typeHandlersPackage)) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">      scanClasses(this.typeHandlersPackage, TypeHandler.class).stream().filter(clazz -&gt; !clazz.isAnonymousClass())</span>
<span class="pc bpc" id="L555" title="2 of 4 branches missed.">          .filter(clazz -&gt; !clazz.isInterface()).filter(clazz -&gt; !Modifier.isAbstract(clazz.getModifiers()))</span>
<span class="fc" id="L556">          .forEach(targetConfiguration.getTypeHandlerRegistry()::register);</span>
    }

<span class="fc bfc" id="L559" title="All 2 branches covered.">    if (!isEmpty(this.typeHandlers)) {</span>
<span class="fc" id="L560">      Stream.of(this.typeHandlers).forEach(typeHandler -&gt; {</span>
<span class="fc" id="L561">        targetConfiguration.getTypeHandlerRegistry().register(typeHandler);</span>
<span class="pc" id="L562">        LOGGER.debug(() -&gt; &quot;Registered type handler: '&quot; + typeHandler + &quot;'&quot;);</span>
<span class="fc" id="L563">      });</span>
    }

<span class="fc" id="L566">    targetConfiguration.setDefaultEnumTypeHandler(defaultEnumTypeHandler);</span>

<span class="fc bfc" id="L568" title="All 2 branches covered.">    if (!isEmpty(this.scriptingLanguageDrivers)) {</span>
<span class="fc" id="L569">      Stream.of(this.scriptingLanguageDrivers).forEach(languageDriver -&gt; {</span>
<span class="fc" id="L570">        targetConfiguration.getLanguageRegistry().register(languageDriver);</span>
<span class="pc" id="L571">        LOGGER.debug(() -&gt; &quot;Registered scripting language driver: '&quot; + languageDriver + &quot;'&quot;);</span>
<span class="fc" id="L572">      });</span>
    }
<span class="fc" id="L574">    Optional.ofNullable(this.defaultScriptingLanguageDriver)</span>
<span class="fc" id="L575">        .ifPresent(targetConfiguration::setDefaultScriptingLanguage);</span>

<span class="pc bpc" id="L577" title="1 of 2 branches missed.">    if (this.databaseIdProvider != null) {// fix #64 set databaseId before parse mapper xmls</span>
      try {
<span class="nc" id="L579">        targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));</span>
<span class="nc" id="L580">      } catch (SQLException e) {</span>
<span class="nc" id="L581">        throw new IOException(&quot;Failed getting a databaseId&quot;, e);</span>
<span class="nc" id="L582">      }</span>
    }

<span class="fc" id="L585">    Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache);</span>

<span class="fc bfc" id="L587" title="All 2 branches covered.">    if (xmlConfigBuilder != null) {</span>
      try {
<span class="fc" id="L589">        xmlConfigBuilder.parse();</span>
<span class="pc" id="L590">        LOGGER.debug(() -&gt; &quot;Parsed configuration file: '&quot; + this.configLocation + &quot;'&quot;);</span>
<span class="nc" id="L591">      } catch (Exception ex) {</span>
<span class="nc" id="L592">        throw new IOException(&quot;Failed to parse config resource: &quot; + this.configLocation, ex);</span>
      } finally {
<span class="fc" id="L594">        ErrorContext.instance().reset();</span>
      }
    }

<span class="fc" id="L598">    targetConfiguration.setEnvironment(new Environment(this.environment,</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">        this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory,</span>
        this.dataSource));

<span class="fc bfc" id="L602" title="All 2 branches covered.">    if (this.mapperLocations != null) {</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">      if (this.mapperLocations.length == 0) {</span>
<span class="fc" id="L604">        LOGGER.warn(() -&gt; &quot;Property 'mapperLocations' was specified but matching resources are not found.&quot;);</span>
      } else {
<span class="fc bfc" id="L606" title="All 2 branches covered.">        for (Resource mapperLocation : this.mapperLocations) {</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">          if (mapperLocation == null) {</span>
<span class="fc" id="L608">            continue;</span>
          }
          try {
<span class="fc" id="L611">            XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),</span>
<span class="fc" id="L612">                targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments());</span>
<span class="fc" id="L613">            xmlMapperBuilder.parse();</span>
<span class="nc" id="L614">          } catch (Exception e) {</span>
<span class="nc" id="L615">            throw new IOException(&quot;Failed to parse mapping resource: '&quot; + mapperLocation + &quot;'&quot;, e);</span>
          } finally {
<span class="fc" id="L617">            ErrorContext.instance().reset();</span>
          }
<span class="pc" id="L619">          LOGGER.debug(() -&gt; &quot;Parsed mapper file: '&quot; + mapperLocation + &quot;'&quot;);</span>
        }
      }
    } else {
<span class="pc" id="L623">      LOGGER.debug(() -&gt; &quot;Property 'mapperLocations' was not specified.&quot;);</span>
    }

<span class="fc" id="L626">    return this.sqlSessionFactoryBuilder.build(targetConfiguration);</span>
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public SqlSessionFactory getObject() throws Exception {
<span class="fc bfc" id="L634" title="All 2 branches covered.">    if (this.sqlSessionFactory == null) {</span>
<span class="fc" id="L635">      afterPropertiesSet();</span>
    }

<span class="fc" id="L638">    return this.sqlSessionFactory;</span>
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public Class&lt;? extends SqlSessionFactory&gt; getObjectType() {
<span class="fc bfc" id="L646" title="All 2 branches covered.">    return this.sqlSessionFactory == null ? SqlSessionFactory.class : this.sqlSessionFactory.getClass();</span>
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean isSingleton() {
<span class="fc" id="L654">    return true;</span>
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public void onApplicationEvent(ApplicationEvent event) {
<span class="pc bpc" id="L662" title="3 of 4 branches missed.">    if (failFast &amp;&amp; event instanceof ContextRefreshedEvent) {</span>
      // fail-fast -&gt; check all statements are completed
<span class="nc" id="L664">      this.sqlSessionFactory.getConfiguration().getMappedStatementNames();</span>
    }
<span class="fc" id="L666">  }</span>

  private Set&lt;Class&lt;?&gt;&gt; scanClasses(String packagePatterns, Class&lt;?&gt; assignableType) throws IOException {
<span class="fc" id="L669">    Set&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L670">    String[] packagePatternArray = tokenizeToStringArray(packagePatterns,</span>
        ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
<span class="fc bfc" id="L672" title="All 2 branches covered.">    for (String packagePattern : packagePatternArray) {</span>
<span class="fc" id="L673">      Resource[] resources = RESOURCE_PATTERN_RESOLVER.getResources(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX</span>
<span class="fc" id="L674">          + ClassUtils.convertClassNameToResourcePath(packagePattern) + &quot;/**/*.class&quot;);</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">      for (Resource resource : resources) {</span>
        try {
<span class="fc" id="L677">          ClassMetadata classMetadata = METADATA_READER_FACTORY.getMetadataReader(resource).getClassMetadata();</span>
<span class="fc" id="L678">          Class&lt;?&gt; clazz = Resources.classForName(classMetadata.getClassName());</span>
<span class="fc bfc" id="L679" title="All 4 branches covered.">          if (assignableType == null || assignableType.isAssignableFrom(clazz)) {</span>
<span class="fc" id="L680">            classes.add(clazz);</span>
          }
<span class="nc" id="L682">        } catch (Throwable e) {</span>
<span class="nc" id="L683">          LOGGER.warn(() -&gt; &quot;Cannot load the '&quot; + resource + &quot;'. Cause by &quot; + e.toString());</span>
<span class="fc" id="L684">        }</span>
      }
    }
<span class="fc" id="L687">    return classes;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>